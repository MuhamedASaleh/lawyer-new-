<!-- 
 <!DOCTYPE html>
 <html>
 <head>
     <title>Voice and Video Call with WebRTC and Socket.io</title>
 </head>
 <body>
     <h1>Voice and Video Call</h1>
     <button id="startVoiceCall">Start Voice Call</button>
     <button id="startVideoCall">Start Video Call</button>
     <button id="endCall" style="display:none;">End Call</button>
     <audio id="remoteAudio" autoplay></audio>
     <video id="localVideo" autoplay muted style="width: 300px; height: 300px; display:none;"></video>
     <video id="remoteVideo" autoplay style="width: 300px; height: 300px; display:none;"></video>
     <div id="callNotification" style="display:none;">
         <p>Incoming call from <span id="callerName"></span></p>
         <button id="acceptCall">Accept</button>
         <button id="rejectCall">Reject</button>
     </div>
     <div id="endCallNotification" style="display:none;">
         <p>The call has ended.</p>
     </div>
     <script src="/socket.io/socket.io.js"></script>
     <script>
         const socket = io();
 
         const startVoiceCallButton = document.getElementById('startVoiceCall');
         const startVideoCallButton = document.getElementById('startVideoCall');
         const endCallButton = document.getElementById('endCall');
         const remoteAudio = document.getElementById('remoteAudio');
         const localVideo = document.getElementById('localVideo');
         const remoteVideo = document.getElementById('remoteVideo');
         const callNotification = document.getElementById('callNotification');
         const callerName = document.getElementById('callerName');
         const acceptCallButton = document.getElementById('acceptCall');
         const rejectCallButton = document.getElementById('rejectCall');
         const endCallNotification = document.getElementById('endCallNotification');
 
         let localStream;
         let peerConnection;
         let remoteUserId;
         let isVideoCall = false;
 
         const configuration = {
             iceServers: [
                 { urls: 'stun:stun.l.google.com:19302' }
             ]
         };
 
         async function startCall(video) {
             try {
                 localStream = await navigator.mediaDevices.getUserMedia({ video: video, audio: true });
                 if (video) {
                     localVideo.srcObject = localStream;
                     localVideo.style.display = 'block';
                 } else {
                     remoteAudio.srcObject = localStream;
                 }
 
                 peerConnection = new RTCPeerConnection(configuration);
 
                 localStream.getTracks().forEach(track => {
                     peerConnection.addTrack(track, localStream);
                 });
 
                 peerConnection.onicecandidate = event => {
                     if (event.candidate) {
                         socket.emit('candidate', {
                             candidate: event.candidate.toJSON(),
                             target: remoteUserId
                         });
                     }
                 };
 
                 peerConnection.ontrack = event => {
                     if (event.track.kind === 'video') {
                         remoteVideo.srcObject = event.streams[0];
                         remoteVideo.style.display = 'block';
                     } else {
                         remoteAudio.srcObject = event.streams[0];
                     }
                 };
 
                 const offer = await peerConnection.createOffer();
                 await peerConnection.setLocalDescription(offer);
 
                 socket.emit('offer', {
                     sdp: peerConnection.localDescription,
                     target: remoteUserId,
                     video: video
                 });
 
                 // Show end call button and hide start call buttons
                 startVoiceCallButton.style.display = 'none';
                 startVideoCallButton.style.display = 'none';
                 endCallButton.style.display = 'block';
                 isVideoCall = video;
             } catch (error) {
                 console.error('Error starting call:', error);
             }
         }
 
         startVoiceCallButton.onclick = () => startCall(false);
         startVideoCallButton.onclick = () => startCall(true);
         socket.on('incomingCall', async data => {
             // Set the remote user ID
             remoteUserId = data.caller;
             isVideoCall = data.video;
 
             // Show call notification
             callNotification.style.display = 'block';
             callerName.textContent = remoteUserId;
 
             // Handle call acceptance
             acceptCallButton.onclick = async () => {
                 callNotification.style.display = 'none';
 
                 try {
                     peerConnection = new RTCPeerConnection(configuration);
 
                     peerConnection.onicecandidate = event => {
                         if (event.candidate) {
                             socket.emit('candidate', {
                                 candidate: event.candidate.toJSON(),
                                 target: remoteUserId
                             });
                         }
                     };
 
                     peerConnection.ontrack = event => {
                         if (event.track.kind === 'video') {
                             remoteVideo.srcObject = event.streams[0];
                             remoteVideo.style.display = 'block';
                         } else {
                             remoteAudio.srcObject = event.streams[0];
                         }
                     };
 
                     localStream = await navigator.mediaDevices.getUserMedia({ video: isVideoCall, audio: true });
                     if (isVideoCall) {
                         localVideo.srcObject = localStream;
                         localVideo.style.display = 'block';
                     } else {
                         remoteAudio.srcObject = localStream;
                     }
 
                     localStream.getTracks().forEach(track => {
                         peerConnection.addTrack(track, localStream);
                     });
 
                     await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
 
                     const answer = await peerConnection.createAnswer();
                     await peerConnection.setLocalDescription(answer);
 
                     socket.emit('answer', {
                         sdp: peerConnection.localDescription,
                         target: remoteUserId
                     });
 
                     // Show end call button and hide start call buttons
                     startVoiceCallButton.style.display = 'none';
                     startVideoCallButton.style.display = 'none';
                     endCallButton.style.display = 'block';
                 } catch (error) {
                     console.error('Error accepting call:', error);
                 }
             };
 
             // Handle call rejection
             rejectCallButton.onclick = () => {
                 callNotification.style.display = 'none';
             };
         });
 
         socket.on('answer', async data => {
             try {
                 await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
             } catch (error) {
                 console.error('Error handling answer:', error);
             }
         });
 
         socket.on('candidate', async data => {
             try {
                 const candidate = new RTCIceCandidate(data.candidate);
                 await peerConnection.addIceCandidate(candidate);
             } catch (error) {
                 console.error('Error adding received ICE candidate:', error);
             }
         });
 
         endCallButton.onclick = () => {
             if (peerConnection) {
                 peerConnection.close();
                 peerConnection = null;
                 socket.emit('endCall', { target: remoteUserId });
                 startVoiceCallButton.style.display = 'block';
                 startVideoCallButton.style.display = 'block';
                 endCallButton.style.display = 'none';
                 localVideo.style.display = 'none';
                 remoteVideo.style.display = 'none';
             }
         };
 
         // Listen for call end notifications
         socket.on('endCallNotification', () => {
             endCallNotification.style.display = 'block';
             setTimeout(() => {
                 endCallNotification.style.display = 'none';
             }, 3000); // Hide notification after 3 seconds
             startVoiceCallButton.style.display = 'block';
             startVideoCallButton.style.display = 'block';
             endCallButton.style.display = 'none';
             localVideo.style.display = 'none';
             remoteVideo.style.display = 'none';
         });
 
         // Emit a signal to notify when a new user connects
         socket.emit('new-user', { userId: socket.id });
 
         // Listen for new users to set remote user ID
         socket.on('new-user', data => {
             if (!remoteUserId) {
                 remoteUserId = data.userId;
             }
         });
     </script>
 </body>
 </html>
   -->
<!--  -->



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socket.io Video Call Test</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        #userList {
            list-style: none;
            padding: 0;
        }
        #userList li {
            padding: 5px;
            display: flex;
            align-items: center;
        }
        #userList li:hover {
            background-color: #eee;
        }
        #room {
            display: none;
        }
        .call-button {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        .call-button:hover {
            background-color: #0056b3;
        }
        audio {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Socket.io Video Call Test</h1>
    <div>
        <h2>Online Users</h2>
        <ul id="userList"></ul>
    </div>
    <div id="room">
        <h2>Room</h2>
        <p id="roomId"></p>
        <div id="roomUsers"></div>
        <audio id="localAudio" autoplay></audio>
        <audio id="remoteAudio" autoplay></audio>
    </div>

    <script>
        const userId = prompt("Enter your user ID");
        const socket = io('/');
        let localStream;
        let remoteStream;
        let peerConnection;
        const peerConnectionConfig = {
            'iceServers': [
                { 'urls': 'stun:stun.stunprotocol.org:3478' },
                { 'urls': 'stun:stun.l.google.com:19302' }
            ]
        };

        // Add the user to the online users list
        socket.emit('add-user', userId);

        // Listen for updates to the online users list
        socket.on('update-online-users', (data) => {
            const userList = document.getElementById('userList');
            userList.innerHTML = '';
            data.onlineUsers.forEach(user => {
                if (user.userId !== userId) { // Don't list the current user
                    const listItem = document.createElement('li');
                    listItem.textContent = user.userId;

                    const callButton = document.createElement('button');
                    callButton.textContent = 'Voice Call';
                    callButton.className = 'call-button';
                    callButton.addEventListener('click', () => initiateCall(user.userId));

                    listItem.appendChild(callButton);
                    userList.appendChild(listItem);
                }
            });
        });

        // When the user clicks the call button
        function initiateCall(calleeId) {
            const roomId = `room-${userId}-${calleeId}`; // Generate a unique room ID
            socket.emit('join-private-room', { roomId, callerId: userId, calleeId });
        }

        // Listen for instructions to join a room
        socket.on('join-room', async (data) => {
            console.log('Joining room:', data.roomId);
            document.getElementById('room').style.display = 'block';
            document.getElementById('roomId').textContent = `Room ID: ${data.roomId}`;
            document.getElementById('roomUsers').textContent = `Users in room: ${userId}`;

            await startLocalStream();
            setupPeerConnection();

            if (data.callerId !== userId) {
                createOffer();
            }
        });

        // Listen for new user notifications in the room
        socket.on('new-user', (data) => {
            console.log('New user in room:', data);
            document.getElementById('roomUsers').textContent = `Users in room: ${data.callerId} and ${data.calleeId}`;
        });

        // Listen for user disconnection notifications
        socket.on('user-disconnected', (data) => {
            console.log('User disconnected:', data);
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
        });

        // WebRTC functions
        async function startLocalStream() {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            document.getElementById('localAudio').srcObject = localStream;
        }

        function setupPeerConnection() {
            peerConnection = new RTCPeerConnection(peerConnectionConfig);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', { candidate: event.candidate });
                }
            };

            peerConnection.ontrack = (event) => {
                remoteStream = new MediaStream();
                document.getElementById('remoteAudio').srcObject = remoteStream;
                remoteStream.addTrack(event.track);
            };

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }

        function createOffer() {
            peerConnection.createOffer()
                .then(offer => {
                    return peerConnection.setLocalDescription(offer);
                })
                .then(() => {
                    socket.emit('offer', { offer: peerConnection.localDescription });
                });
        }

        socket.on('offer', (data) => {
            peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer))
                .then(() => {
                    return peerConnection.createAnswer();
                })
                .then(answer => {
                    return peerConnection.setLocalDescription(answer);
                })
                .then(() => {
                    socket.emit('answer', { answer: peerConnection.localDescription });
                });
        });

        socket.on('answer', (data) => {
            peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        });

        socket.on('ice-candidate', (data) => {
            peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        });
    </script>
</body>
</html>
